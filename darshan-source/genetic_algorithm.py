"""Runs a genetic algorithm on the specified target objective.

Example usage:
    config = <GENERATE CONFIG OBJECT>
    genetic_algorithm_instance = GeneticAlgorithm(config)
    genetic_algorithm_instance.run()
"""

import random
import statistics

from absl import logging
from deap import base
from deap import creator
from deap import tools
import numpy as np

import paci_2018


class GeneticAlgorithm:
    """Encapsulates state and behavior of a genetic algorithm.

    Attributes:
        config: A configs.GeneticAlgorithmConfig object specifying genetic
            algorithm hyperparameters.
        baseline_trace: The baseline trace which will serve as the algorithm's
            target objective.
    """

    def __init__(self, config):
        self.config = config
        self.baseline_trace = self._generate_trace()

    def run(self):
        """Runs the instance of the genetic algorithm."""
        toolbox = _configure_toolbox(self.config)
        population = toolbox.population(self.config.population_size)

        logging.info('Evaluating initial population.')
        for individual in population:
            individual.fitness.values = [toolbox.evaluate(self, individual[0])]

        for generation in range(self.config.max_generations):
            logging.info('Generation %d', generation + 1)
            # Offspring are chosen through tournament selection. They are then
            # clones, because they will be modified in-place later on.
            offspring = list(map(
                toolbox.clone,
                toolbox.select(population, len(population))))

            logging.info('Crossing over.')
            for i_one, i_two in zip(offspring[::2], offspring[1::2]):
                if random.random() < self.config.crossover_probability:
                    toolbox.mate(self, i_one, i_two)
                    del i_one.fitness.values
                    del i_two.fitness.values

            logging.info('Mutating.')
            for i in offspring:
                toolbox.mutate(self, i)
                del i.fitness.values

            logging.info('Updating fitness.')
            # All individuals who were updated, either through crossover or
            # mutation, will be re-evaluated.
            updated_individuals = [i for i in offspring if not i.fitness.values]
            for individual in updated_individuals:
                individual.fitness.values = [
                    toolbox.evaluate(self, individual[0])
                ]

            population = offspring
            _generate_statistics(population)

    def _generate_trace(self, params=None):
        """Generates a trace given a set of parameters.

        Leave `params` argument empty if generating baseline trace with
        default parameter values.

        Returns:
            A Trace object.
        """
        new_params = dict()
        if params:
            for i in range(len(params)):
                new_params[self.config.tunable_parameters[i].name] = params[i]

        return paci_2018.PaciModel(
            updated_parameters=new_params).generate_response(
            self.config.target_objective)

    def evaluate_performance(self, new_parameters):
        """Evaluates performance of an individual compared to the target obj.

        Args:
            new_parameters: Parameters to be updated.

        Returns:
            The error between the trace generated by the individual's parameter
            set and the baseline target objective.
        """
        return _calculate_error(
            self.baseline_trace,
            self._generate_trace(new_parameters))

    def mate(self, i_one, i_two):
        """Performs crossover between two individuals.

        There may be a possibility no parameters are swapped. This probability
        is controlled by `self.config.parameter_swap_probability`. Modifies
        both individuals in-place.

        Args:
            i_one: An individual in a population.
            i_two: Another individual in the population.
        """
        for i in range(len(i_one[0])):
            if random.random() < self.config.parameter_swap_probability:
                i_one[0][i], i_two[0][i] = i_two[0][i], i_one[0][i]

    def mutate(self, individual):
        """Performs a mutation on an individual in the population.

        Chooses random parameter values from the normal distribution centered
        around each of the original parameter values. Modifies individual
        in-place.

        Args:
            individual: An individual in the population.
        """
        for i in range(len(individual[0])):
            if random.random() < self.config.gene_mutation_probability:
                individual[0][i] = np.random.normal(individual[0][i])


def _configure_toolbox(config):
    """Configures toolbox functions."""
    creator.create('FitnessMin', base.Fitness, weights=(-1.0,))
    creator.create('Individual', list, fitness=creator.FitnessMin)

    toolbox = base.Toolbox()
    toolbox.register('init_param', lambda: _initialize_parameters(config))
    toolbox.register(
        'individual',
        tools.initRepeat,
        creator.Individual,
        toolbox.init_param,
        n=1)
    toolbox.register('population', tools.initRepeat, list, toolbox.individual)
    toolbox.register('evaluate', GeneticAlgorithm.evaluate_performance)
    toolbox.register('select', tools.selTournament, tournsize=3)
    toolbox.register('mate', GeneticAlgorithm.mate)
    toolbox.register('mutate', GeneticAlgorithm.mutate)
    return toolbox


def _initialize_parameters(config):
    """Initializes random values within constraints of all tunable params.

    Args:
        config: A configs.GeneticAlgorithmConfig object containing all
            parameters to be tuned, as well as the upper and lower boundaries
            of parameter values.

    Returns:
        A new set of randomly generated parameter values.
    """
    # Build a list of parameters using random upper and lower boudns
    randomized_parameters = []
    for param in config.tunable_parameters:
        random_param = random.uniform(
            param.default_value * config.params_lower_bound,
            param.default_value * config.params_upper_bound)
        randomized_parameters.append(random_param)
    return randomized_parameters


def _calculate_error(baseline_trace, other_trace):
    # TODO Implement interpolation method.
    error = 0
    for i in range(0, min(len(baseline_trace.t), len(other_trace.t))):
        error += abs(baseline_trace.y[0][i] - other_trace.y[0][i]) ** 2
    return error


def _generate_statistics(population):
    fitness_values = [i.fitness.values[0] for i in population]
    print('  Min error: {}'.format(min(fitness_values)))
    print('  Max error: {}'.format(max(fitness_values)))
    print('  Average error: {}'.format(statistics.mean(fitness_values)))
    print('  Standard deviation: {}'.format(statistics.stdev(fitness_values)))

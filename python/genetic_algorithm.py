"""Runs a genetic algorithm on the specified target objective.

Example usage:
    config = <GENERATE CONFIG OBJECT>
    genetic_algorithm_instance = GeneticAlgorithm(config)
    genetic_algorithm_instance.run()
"""

import random
from typing import List

from deap import base
from deap import creator
from deap import tools
import numpy as np
import scipy.interpolate

import ga_config
import genetic_algorithm_result
import paci_2018
import protocols


class GeneticAlgorithm:
    """Encapsulates state and behavior of a genetic algorithm.

    Attributes:
        config: A config object specifying genetic algorithm hyperparameters.
        baseline_trace: Trace which will serve as the algorithm's target
            objective.
    """

    def __init__(self, config: ga_config.GeneticAlgorithmConfig) -> None:
        self.config = config
        self.baseline_trace = paci_2018.generate_trace(config)

    def run(self) -> genetic_algorithm_result.GeneticAlgorithmResult:
        """Runs an instance of the genetic algorithm."""
        toolbox = self._configure_toolbox()
        population = toolbox.population(self.config.population_size)
        ga_result = genetic_algorithm_result.GeneticAlgorithmResult(
            config=self.config,
            baseline_trace=self.baseline_trace)

        print('Evaluating initial population.')
        for individual in population:
            individual.fitness.values = [toolbox.evaluate(self, individual[0])]

        # Store initial population details for result processing.
        initial_population = []
        for i in range(len(population)):
            initial_population.append(
                genetic_algorithm_result.IndividualResult(
                    param_set=population[i][0],
                    error=population[i].fitness.values[0]))
        ga_result.generations.append(initial_population)

        for generation in range(1, self.config.max_generations):
            print('Generation {}'.format(generation))
            # Offspring are chosen through tournament selection. They are then
            # cloned, because they will be modified in-place later on.
            selected_offspring = toolbox.select(population, len(population))
            offspring = [toolbox.clone(i) for i in selected_offspring]

            for i_one, i_two in zip(offspring[::2], offspring[1::2]):
                if random.random() < self.config.crossover_probability:
                    toolbox.mate(self, i_one, i_two)
                    del i_one.fitness.values
                    del i_two.fitness.values

            for i in offspring:
                toolbox.mutate(self, i)
                del i.fitness.values

            # All individuals who were updated, either through crossover or
            # mutation, will be re-evaluated.
            updated_individuals = [i for i in offspring if not i.fitness.values]
            for individual in updated_individuals:
                individual.fitness.values = [
                    toolbox.evaluate(self, individual[0])
                ]

            population = offspring

            # Store intermediate population details for result processing.
            intermediate_population = []
            for i in range(len(population)):
                intermediate_population.append(
                    genetic_algorithm_result.IndividualResult(
                        param_set=population[i][0],
                        error=population[i].fitness.values[0]))
            ga_result.generations.append(intermediate_population)

            generate_statistics(population)
        return ga_result

    def _evaluate_performance(self, new_parameters: List[float]) -> float:
        """Evaluates performance of an individual compared to the target obj.

        Args:
            new_parameters: New parameters to use in the model.

        Returns:
            The error between the trace generated by the individual's parameter
            set and the baseline target objective.
        """
        trace = paci_2018.generate_trace(self.config, new_parameters)

        # Individual could not produce valid trace
        if not trace:
            return self.config.MAX_ERROR

        error = 0
        # If a voltage clamp protocol was used, calculate error based on
        # current, not voltage.
        if isinstance(self.config.protocol, protocols.VoltageClampProtocol):
            base_interp = scipy.interpolate.interp1d(
                self.baseline_trace.t,
                self.baseline_trace.current_response_info.get_current_summed())

            currents = trace.current_response_info.get_current_summed()
            for i in range(len(trace.t)):
                error += (base_interp(trace.t[i]) - currents[i]) ** 2
        else:
            base_interp = scipy.interpolate.interp1d(
                self.baseline_trace.t,
                self.baseline_trace.y)
            for i in range(len(trace.t)):
                error += (base_interp(trace.t[i]) - trace.y[i]) ** 2

        return error

    def _mate(self, i_one: List[List[float]], i_two: List[List[float]]) -> None:
        """Performs crossover between two individuals.

        There may be a possibility no parameters are swapped. This probability
        is controlled by `self.config.parameter_swap_probability`. Modifies
        both individuals in-place.

        Args:
            i_one: An individual in a population.
            i_two: Another individual in the population.
        """
        for i in range(len(i_one[0])):
            if random.random() < self.config.parameter_swap_probability:
                i_one[0][i], i_two[0][i] = i_two[0][i], i_one[0][i]

    def _mutate(self, individual: List[List[float]]) -> None:
        """Performs a mutation on an individual in the population.

        Chooses random parameter values from the normal distribution centered
        around each of the original parameter values. Modifies individual
        in-place.

        Args:
            individual: An individual to be mutated.
        """
        for i in range(len(individual[0])):
            if random.random() < self.config.gene_mutation_probability:
                individual[0][i] = np.random.normal(individual[0][i])

    def _initialize_parameters(self) -> List[float]:
        """Initializes random values within constraints of all tunable params.

        Returns:
            A new set of randomly generated parameter values.
        """
        # Builds a list of parameters using random upper and lower bounds.
        randomized_parameters = []
        for param in self.config.tunable_parameters:
            random_param = random.uniform(
                param.default_value * self.config.params_lower_bound,
                param.default_value * self.config.params_upper_bound)
            randomized_parameters.append(random_param)
        return randomized_parameters

    def _configure_toolbox(self) -> base.Toolbox:
        """Configures toolbox functions."""
        creator.create('FitnessMin', base.Fitness, weights=(-1.0,))
        creator.create('Individual', list, fitness=creator.FitnessMin)

        toolbox = base.Toolbox()
        toolbox.register('init_param', self._initialize_parameters)
        toolbox.register(
            'individual',
            tools.initRepeat,
            creator.Individual,
            toolbox.init_param,
            n=1)
        toolbox.register(
            'population',
            tools.initRepeat,
            list,
            toolbox.individual)
        toolbox.register('evaluate', GeneticAlgorithm._evaluate_performance)
        toolbox.register('select', tools.selTournament,
                         tournsize=self.config.tournament_size)
        toolbox.register('mate', GeneticAlgorithm._mate)
        toolbox.register('mutate', GeneticAlgorithm._mutate)
        return toolbox


def generate_statistics(population: List[List[List[float]]]) -> None:
    fitness_values = [i.fitness.values[0] for i in population]
    print('  Min error: {}'.format(min(fitness_values)))
    print('  Max error: {}'.format(max(fitness_values)))
    print('  Average error: {}'.format(np.mean(fitness_values)))
    print('  Standard deviation: {}'.format(np.std(fitness_values)))
